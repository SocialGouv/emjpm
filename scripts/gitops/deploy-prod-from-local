#!/usr/bin/env bash
set -e

if ((BASH_VERSINFO[0] < 4)); then
    echo "Sorry, you need at least bash-4.0 to run this script." >&2
exit 1; fi

export PKG_VERSION=`node -p "require('./lerna.json').version"`
export TAG=${TAG:-"$PKG_VERSION-local_build"}
echo "Building and deploying eMJPM $TAG"

# global variables
export DOMAIN="emjpm.fabrique.social.gouv.fr";
export API_HOST="api-${DOMAIN}";
export API_PORT="4000";
export APP_HOST="${DOMAIN}";
export APP_PORT="3000";
export HASURA_HOST="hasura-${DOMAIN}";
export HASURA_PORT="80";

# build and push variables
export BUILD_ENV=${BUILD_ENV:-"pure"}
export REGISTRY="registry.gitlab.factory.social.gouv.fr/socialgouv/emjpm/local_build"
export REACT_APP_GRAPHQL_SERVER_URI="https://$HASURA_HOST/v1/graphql"
export REACT_APP_API_URL="https://$API_HOST"
export GRAPHQL_SERVER_URI="$REACT_APP_GRAPHQL_SERVER_URI"
export APP_API_URL="$REACT_APP_API_URL"

# deploy variables
export KUBECTL_CONTEXT=${KUBECTL_CONTEXT:-"prod2"}
export K8S_NAMESPACE=${K8S_NAMESPACE:-"emjpm"}
if [ -f ".kubeconfig" ]; then
  export KUBECONFIG=".kubeconfig:$KUBECONFIG"
fi
export API_SRV_HOST="api:4000";
export HASURA_SRV_HOST="hasura";
export NODE_ENV="production"
source .env.prod
if [ -z "$PG_HOST" ]; then
  echo "missing PG_HOST env variable, provid it in .env.prod" >&2
  exit 1
fi
if [ -z "$EMJPM_PG_USER" ]; then
  echo "missing EMJPM_PG_USER env variable, provid it in .env.prod" >&2
  exit 1
fi
if [ -z "$EMJPM_PG_PASSWORD" ]; then
  echo "missing EMJPM_PG_PASSWORD env variable, provid it in .env.prod" >&2
  exit 1
fi
function urlencode {
  STDIN=`cat /dev/stdin`
  local length="${#STDIN}"
  for (( i = 0; i < length; i++ )); do
      local c="${STDIN:i:1}"
      case $c in
          [a-zA-Z0-9.~_-]) printf "$c" ;;
          *) printf '%s' "$c" | xxd -p -c1 |
                 while read c; do printf '%%%s' "$c"; done ;;
      esac
  done
}
export POSTGRES_EMJPM_USER_ENCODED=$(echo "$EMJPM_PG_USER" | urlencode)
export POSTGRES_EMJPM_PASSWORD_ENCODED=$(echo "$EMJPM_PG_PASSWORD" | urlencode)
export POSTGRES_DATABASE_EMJPM=${POSTGRES_DATABASE_EMJPM:-"emjpm"}
export EMJPM_PG_USER_ENCODED=$POSTGRES_EMJPM_USER_ENCODED
export EMJPM_PG_PASSWORD_ENCODED=$POSTGRES_EMJPM_PASSWORD_ENCODED
export PG_HOST=$PG_HOST


function docker_build {
  local CONTEXT=$1
  local BUILD_ARGS=$2
  docker build \
    -f ./packages/$CONTEXT/Dockerfile \
    -t $REGISTRY/$CONTEXT:$TAG \
    --cache-from $REGISTRY/$CONTEXT:latest \
    --cache-from $REGISTRY/$CONTEXT:$TAG \
    $BUILD_ARGS \
    .
  docker push $REGISTRY/$CONTEXT:$TAG
}

function docker_build_node_multistage {
  local CONTEXT=$1
  local BUILDER_BUILD_ARGS=$2

  ## build pre-dependencies
  docker build \
    -f ./packages/$CONTEXT/Dockerfile \
    --target pre-dependencies \
    -t $REGISTRY/$CONTEXT.pre-dependencies \
    -t $REGISTRY/$CONTEXT.pre-dependencies:$TAG \
    .
  # docker push $REGISTRY/$CONTEXT.pre-dependencies:$TAG

  ## build dependencies_${BUILD_ENV}
  docker build \
    -f ./packages/$CONTEXT/Dockerfile \
    --target dependencies_${BUILD_ENV} \
    -t $REGISTRY/$CONTEXT.dependencies_${BUILD_ENV}:$TAG \
    --cache-from $REGISTRY/$CONTEXT.pre-dependencies \
    .
  # docker push $REGISTRY/$CONTEXT.dependencies_${BUILD_ENV}:$TAG

  ## build dependencies
  docker build \
    -f ./packages/$CONTEXT/Dockerfile \
    --target dependencies \
    --build-arg BUILD_ENV=${BUILD_ENV} \
    -t $REGISTRY/$CONTEXT.dependencies:$TAG \
    --cache-from $REGISTRY/$CONTEXT.dependencies_${BUILD_ENV} \
    .
  # docker push $REGISTRY/$CONTEXT.dependencies:$TAG

  ## build builder
  docker build \
    -f ./packages/$CONTEXT/Dockerfile \
    --target builder \
    -t $REGISTRY/$CONTEXT.builder:$TAG \
    --cache-from $REGISTRY/$CONTEXT.dependencies \
    $BUILDER_BUILD_ARGS \
    .
  # docker push $REGISTRY/$CONTEXT:$TAG.builder

  ## build server
  docker build \
    -f ./packages/$CONTEXT/Dockerfile \
    --target server \
    -t $REGISTRY/$CONTEXT:$TAG \
    --cache-from $REGISTRY/$CONTEXT.builder \
    .
  docker push $REGISTRY/$CONTEXT:$TAG
}

function deploy_production {
  local CONTEXT=$1
  export HOST=$2
  export PORT=$3

  HELM_RENDER_ARGS="
    --set image.repository=${REGISTRY}/${CONTEXT}
    --set image.tag=${TAG}
    --set image.pullPolicy=Always
    --set ingress.hosts[0].host=${HOST}
    --set ingress.tls[0].hosts[0]=${HOST}
    --set ingress.annotations.certmanager\.k8s\.io/cluster-issuer=letsencrypt-prod
    --set-string ingress.annotations.kubernetes\.io/tls-acme=true
  "

  envsubst < packages/$CONTEXT/.k8s/values.yaml \
    | helm template ${HELM_RENDER_ARGS} ${CONTEXT} packages/$CONTEXT/.k8s \
      --values - \
      > packages/$CONTEXT/.k8s/manifests/chart-generated.yaml

  kubectl config use-context $KUBECTL_CONTEXT
  kubectl -n ${K8S_NAMESPACE} apply -f packages/$CONTEXT/.k8s/manifests
}

# docker_build hasura
docker-compose -f docker-compose.build.yaml build hasura
docker-compose -f docker-compose.build.yaml push hasura

# docker_build_node_multistage api
docker-compose -f docker-compose.build.yaml build api
docker-compose -f docker-compose.build.yaml push api

# docker_build_node_multistage app "
#   --build-arg REACT_APP_GRAPHQL_SERVER_URI=${REACT_APP_GRAPHQL_SERVER_URI}
#   --build-arg REACT_APP_API_URL=${REACT_APP_API_URL}"
docker-compose -f docker-compose.build.yaml build app
docker-compose -f docker-compose.build.yaml push app

deploy_production "hasura" "$HASURA_HOST" "$HASURA_PORT"
deploy_production "api" "$API_HOST" "$API_PORT"
deploy_production "app" "$APP_HOST" "$APP_PORT"