#!/usr/bin/env bash
set -e

if ((BASH_VERSINFO[0] < 4)); then
    echo "Sorry, you need at least bash-4.0 to run this script." >&2
exit 1; fi

export DOCKER_BUILDKIT=1

export PKG_VERSION=`node -p "require('./lerna.json').version"`
export TAG=${TAG:-"$PKG_VERSION-local_build"}
echo "Building and deploying eMJPM $TAG"

# global variables
export DOMAIN="emjpm.fabrique.social.gouv.fr";
export API_HOST="api-${DOMAIN}";
export API_PORT="4000";
export APP_HOST="${DOMAIN}";
export APP_PORT="3000";
export HASURA_HOST="hasura-${DOMAIN}";
export HASURA_PORT="80";

# build and push variables
export BUILD_ENV=${BUILD_ENV:-"pure"}
export REGISTRY="registry.gitlab.factory.social.gouv.fr/socialgouv/emjpm/local_build"

# deploy variables
export KUBECTL_CONTEXT=${KUBECTL_CONTEXT:-"prod2"}
export K8S_NAMESPACE=${K8S_NAMESPACE:-"emjpm"}
if [ -f ".kubeconfig" ]; then
  export KUBECONFIG=".kubeconfig:$KUBECONFIG"
fi
export API_SRV_HOST="api:4000";
export HASURA_SRV_HOST="hasura";
export NODE_ENV="production"
source .env.prod
if [ -z "$PG_HOST" ]; then
  echo "missing PG_HOST env variable, provid it in .env.prod" >&2
  exit 1
fi
if [ -z "$EMJPM_PG_USER" ]; then
  echo "missing EMJPM_PG_USER env variable, provid it in .env.prod" >&2
  exit 1
fi
if [ -z "$EMJPM_PG_PASSWORD" ]; then
  echo "missing EMJPM_PG_PASSWORD env variable, provid it in .env.prod" >&2
  exit 1
fi
function urlencode {
  STDIN=`cat /dev/stdin`
  local length="${#STDIN}"
  for (( i = 0; i < length; i++ )); do
      local c="${STDIN:i:1}"
      case $c in
          [a-zA-Z0-9.~_-]) printf "$c" ;;
          *) printf '%s' "$c" | xxd -p -c1 |
                 while read c; do printf '%%%s' "$c"; done ;;
      esac
  done
}
export POSTGRES_EMJPM_USER_ENCODED=$(echo "$EMJPM_PG_USER" | urlencode)
export POSTGRES_EMJPM_PASSWORD_ENCODED=$(echo "$EMJPM_PG_PASSWORD" | urlencode)
export POSTGRES_DATABASE_EMJPM=${POSTGRES_DATABASE_EMJPM:-"emjpm"}
export EMJPM_PG_USER_ENCODED=$POSTGRES_EMJPM_USER_ENCODED
export EMJPM_PG_PASSWORD_ENCODED=$POSTGRES_EMJPM_PASSWORD_ENCODED
export PG_HOST=$PG_HOST
export SENTRY_PUBLIC_DSN=$SENTRY_PUBLIC_DSN


function docker_build {
  local CONTEXT=$1
  local BUILD_ARGS=$2
  echo "BUILD $CONTEXT"

  docker build \
    -f ./packages/$CONTEXT/Dockerfile \
    -t $REGISTRY/$CONTEXT:$TAG \
    $BUILD_ARGS \
    .
  docker push $REGISTRY/$CONTEXT:$TAG
}

function docker_build_node_multistage {
  local CONTEXT=$1
  local BUILDER_BUILD_ARGS=$2
  echo "BUILD $CONTEXT"

  docker build \
    -f ./packages/$CONTEXT/Dockerfile \
    --target builder \
    -t $REGISTRY/$CONTEXT.builder \
    -t $REGISTRY/$CONTEXT.builder:$TAG \
    --build-arg BUILD_ENV=$BUILD_ENV \
    $BUILDER_BUILD_ARGS \
    .

  docker build \
    -f ./packages/$CONTEXT/Dockerfile \
    --target server \
    -t $REGISTRY/$CONTEXT:$TAG \
    --build-arg BUILD_ENV=$BUILD_ENV \
    --cache-from $REGISTRY/$CONTEXT.builder \
    .
  docker push $REGISTRY/$CONTEXT:$TAG

}

function deploy_production {
  local CONTEXT=$1
  export HOST=$2
  export PORT=$3

  HELM_RENDER_ARGS="
    --set image.repository=${REGISTRY}/${CONTEXT}
    --set image.tag=${TAG}
    --set image.pullPolicy=Always
    --set ingress.hosts[0].host=${HOST}
    --set ingress.tls[0].hosts[0]=${HOST}
    --set ingress.annotations.certmanager\.k8s\.io/cluster-issuer=letsencrypt-prod
    --set-string ingress.annotations.kubernetes\.io/tls-acme=true
  "

  envsubst < packages/$CONTEXT/.k8s/values.yaml \
    | helm template ${HELM_RENDER_ARGS} ${CONTEXT} packages/$CONTEXT/.k8s \
      --values - \
      > packages/$CONTEXT/.k8s/manifests/chart-generated.yaml

  kubectl config use-context $KUBECTL_CONTEXT
  kubectl -n ${K8S_NAMESPACE} apply -f packages/$CONTEXT/.k8s/manifests
}

start_time=$(date +%s)

docker_build hasura &
CHILD_PID_1=$!
trap "kill $CHILD_PID_1;" SIGTERM SIGINT

docker_build_node_multistage api &
CHILD_PID_2=$!
trap "kill $CHILD_PID_2;" SIGTERM SIGINT

docker_build_node_multistage app "--build-arg SENTRY_PUBLIC_DSN=${SENTRY_PUBLIC_DSN}" &
CHILD_PID_3=$!
trap "kill $CHILD_PID_3;" SIGTERM SIGINT

wait $CHILD_PID_1 $CHILD_PID_2 $CHILD_PID_3

# deploy_production "hasura" "$HASURA_HOST" "$HASURA_PORT"
# deploy_production "api" "$API_HOST" "$API_PORT"
# deploy_production "app" "$APP_HOST" "$APP_PORT"

current_time=$(date +%s)
seconds_elapsed=$(( $current_time - $start_time ))
timestamp=$(date -d"@$seconds_elapsed" -u +%-d:%-H:%-M:%-S)
IFS=':' read -r day hour minute second <<< "$timestamp"
hour="$(( $hour+24*($day-1) ))"
printf "\r%02d:%02d:%02d" $hour $minute $second