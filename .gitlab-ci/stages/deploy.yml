#

include:
  - /.k8s/api/.k8s-deploy-api.yml
  - /.k8s/postgres/.k8s-deploy-postgres.yml
  - /.k8s/hasura/.k8s-deploy-hasura.yml
  - /.k8s/metabase/.k8s-deploy-metabase.yml
  - /.k8s/graphql-server/.k8s-deploy-graphql-server.yml

#

.deploy_stage: &deploy_stage
  stage: "Deploy"
  retry: 1
  dependencies: []
  services:
    - docker:dind
  variables: &deploy_stage_variables
    IMAGE_TAG: $CI_COMMIT_SHA
    REGISTRY: $CI_REGISTRY_IMAGE

.incubateur_stage: &incubateur_stage
  environment:
    name: prod
  only:
    refs:
      - triggers
    variables:
      - $PRODUCTION

.dev_stage: &dev_stage
  environment:
    name: fabrique-dev
  only:
    refs:
      - branches
      - tags
  except:
    variables:
      - $PRODUCTION
#
#
#

.create_namespace: &create_namespace
  <<: *deploy_stage
  extends: .base_docker_kube_image_stage
  stage: "Registration"
  script:
    # Skip the job if the namespace exists
    - "[[ $(kubectl get namespace ${K8S_NAMESPACE}) ]] && exit ${CI_JOB_SKIP_EXIT_CODE:-0}"
    # Or (re)create to ensure new quota are applied
    # - kubectl delete namespaces ${K8S_NAMESPACE} || true
    #
    - kubectl create namespace ${K8S_NAMESPACE}
    - kubectl annotate namespace ${K8S_NAMESPACE} field.cattle.io/projectId=${RANCHER_PROJECT_ID}
    - kubectl annotate namespace ${K8S_NAMESPACE} git/branch=${CI_COMMIT_REF_NAME}
    #
    - envsubst < ./.k8s/quota.yml > ./quota.yml
    - kubectl apply -f ./quota.yml -n ${K8S_NAMESPACE}
    # Remove the default- quota
    - kubectl get resourcequota -n ${K8S_NAMESPACE}
    - kubectl delete $(kubectl get -n ${K8S_NAMESPACE} resourcequota --output=name | grep default-)
    #
    # Create secrets
    - export APP_URL=$(echo $FRONTEND_URL | base64)
    - envsubst < ./.k8s/secret-dev.yml > ./secret-dev.yml
    - kubectl apply -f ./secret-dev.yml -n ${K8S_NAMESPACE}
    #
    # Create azure volume secrets for anonymized export
    - export AZURE_STORAGE_ACCOUNT_NAME=$(kubectl get secret ${K8S_PROJECT}-export-anonymized -n ${K8S_PROJECT}-secret -ojsonpath='{.data.azurestorageaccountname}')
    - export AZURE_STORAGE_ACCOUNT_KEY=$(kubectl get secret ${K8S_PROJECT}-export-anonymized -n ${K8S_PROJECT}-secret -ojsonpath='{.data.azurestorageaccountkey}')
    - envsubst < .k8s/azure-volume-secret.yml > ./azure-volume-secret.yml
    - kubectl apply -f ./azure-volume-secret.yml -n ${K8S_NAMESPACE}

Create namespace:
  <<: *create_namespace
  <<: *dev_stage

#
#
#

.deploy_app: &deploy_app
  extends: .base_docker_helm_image_stage
  script:
    - helm init --client-only
    - helm repo add socialgouv https://github.com/SocialGouv/helm-charts/releases/download/${SOCIALGOUV_HELMCHART_VERSION}
    - envsubst < ./.k8s/app/value.yml > ./value.yml
    - helm upgrade
        ${K8S_PROJECT}-app-${BRANCH_HASH}
        socialgouv/nodejs
        --debug
        --install
        --set image.tag=${IMAGE_TAG}
        --set ingress.annotations."certmanager\.k8s\.io/cluster-issuer"=${LETSENCRYPT_ISSUER}
        --set ingress.hosts[0].host=${FRONTEND_HOST}
        --set ingress.tls[0].hosts[0]=${FRONTEND_HOST}
        --values ./value.yml
        --wait || helm delete --purge ${K8S_PROJECT}-app-${BRANCH_HASH}

#

Deploy App (dev):
  <<: *deploy_stage
  <<: *dev_stage
  <<: *deploy_app
  variables:
    <<: *deploy_stage_variables
    LETSENCRYPT_ISSUER: letsencrypt-staging

Deploy App (incubateur):
  <<: *deploy_stage
  <<: *incubateur_stage
  <<: *deploy_app
  variables:
    <<: *deploy_stage_variables
    LETSENCRYPT_ISSUER: letsencrypt-prod

#
#
#


.deploy_api: &deploy_api
  extends: .base_docker_helm_image_stage
  script:
    - helm init --client-only
    - helm repo add socialgouv https://github.com/SocialGouv/helm-charts/releases/download/${SOCIALGOUV_HELMCHART_VERSION}
    #
    - export POSTGRESQL_USER=emjpm
    - export POSTGRESQL_PASSWORD=$(kubectl get secret emjpm-secret -o jsonpath='{.data.POSTGRES_EMJPM_PASSWORD}' | base64 --decode)
    #
    - envsubst < ./.k8s/api/value.yml > ./value.yml
    - helm upgrade
        ${K8S_PROJECT}-api-${BRANCH_HASH}
        socialgouv/nodejs
        --debug
        --install
        --set image.tag=${IMAGE_TAG}
        --set ingress.annotations."certmanager\.k8s\.io/cluster-issuer"=${LETSENCRYPT_ISSUER}
        --set ingress.hosts[0].host=${API_HOST}
        --set ingress.tls[0].hosts[0]=${API_HOST}
        --values ./value.yml
        --wait || helm delete --purge ${K8S_PROJECT}-api-${BRANCH_HASH}

#

Deploy Api (dev):
  <<: *deploy_stage
  <<: *dev_stage
  <<: *deploy_api
  variables:
    <<: *deploy_stage_variables
    LETSENCRYPT_ISSUER: letsencrypt-staging

Deploy Api (incubateur):
  <<: *deploy_stage
  <<: *incubateur_stage
  <<: *deploy_api
  variables:
    <<: *deploy_stage_variables
    LETSENCRYPT_ISSUER: letsencrypt-prod

#
#
#

.deploy-postgres: &deploy_postgres
  <<: *deploy_stage
  extends: .k8s-deploy-postgres
  variables: &deploy_postgres_stage_variables
    CONTEXT: postgres
    EMJPM_REGISTRY: $CI_REGISTRY_IMAGE
    IMAGE_NAME: $CI_REGISTRY_IMAGE/postgres
    PORT: 5432

#

Deploy postgres (dev):
  <<: *deploy_postgres
  <<: *dev_stage
  variables:
    <<: *deploy_stage_variables
    <<: *deploy_postgres_stage_variables
    PERSISTENCE_ENABLED: "false"

Deploy postgres (incubateur):
  <<: *deploy_postgres
  <<: *incubateur_stage
  variables:
    <<: *deploy_stage_variables
    <<: *deploy_postgres_stage_variables
    PERSISTENCE_ENABLED: "true"

#
#
#

Restore postgres data (dev):
  <<: *deploy_stage
  <<: *dev_stage
  extends: .k8s-restore-postgres-data
  when: manual

#
#
#

.deploy-hasura: &deploy_hasura
  <<: *deploy_stage
  extends: .k8s-deploy-hasura
  variables:
    <<: *deploy_stage_variables
    CONTEXT: hasura
    IMAGE_NAME: $CI_REGISTRY_IMAGE/hasura
    PORT: 80

#

Deploy hasura (dev):
  <<: *deploy_hasura
  <<: *dev_stage

Deploy hasura (incubateur):
  <<: *deploy_hasura
  <<: *incubateur_stage

#
#
#

.deploy-graphql-server: &deploy_graphql-server
  <<: *deploy_stage
  extends: .k8s-deploy-graphql-server
  variables:
    <<: *deploy_stage_variables
    CONTEXT: graphql-server
    IMAGE_NAME: $CI_REGISTRY_IMAGE/graphql-server
    PORT: 80

#

Deploy graphql-server (dev):
  <<: *deploy_graphql-server
  <<: *dev_stage

Deploy graphql-server (incubateur):
  <<: *deploy_graphql-server
  <<: *incubateur_stage

#
#
#

Deploy metabase (incubateur):
  <<: *incubateur_stage
  <<: *deploy_stage
  extends: .k8s-deploy-metabase
  variables:
    <<: *deploy_stage_variables
    CONTEXT: metabase
    PORT: 3000
  after_script:
    # NOTE(douglasduteil): re-run env.sh
    # Because the `after_script` runs in a separated shell context.
    # see https://docs.gitlab.com/ee/ci/variables/where_variables_can_be_used.html#execution-shell-environment
    - source ./.gitlab-ci/env.sh
    - echo "Metabase available at - ${METABASE_URL}"
